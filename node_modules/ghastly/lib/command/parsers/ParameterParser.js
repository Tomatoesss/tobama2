'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringArgv = require('string-argv');

var _stringArgv2 = _interopRequireDefault(_stringArgv);

var _lang = require('lodash/lang');

var _string = require('lodash/string');

var _ParameterParserError = require('../../errors/ParameterParserError');

var _ParameterParserError2 = _interopRequireDefault(_ParameterParserError);

var _ParameterResolver = require('../../resolvers/ParameterResolver');

var _ParameterResolver2 = _interopRequireDefault(_ParameterResolver);

var _ParsedParameter = require('./ParsedParameter');

var _ParsedParameter2 = _interopRequireDefault(_ParsedParameter);

var _Types = require('./Types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} ParameterDefinition
 * @property {string} name - The name of the parameter.
 * @property {string} description - The description of the parameter.
 * @property {boolean} optional - Whether or not the parameter is optional.
 * @property {string} type - The type of the parameter.
 * @property {boolean} repeatable - Whether or not the parameter accepts an array
 *   of values instead of an atomic value.
 * @property {boolean} literal - Whether or not this parameter gets the value of
 *   the entire input string.
 * @property {*} defaultValue - The default value of the parameter, or an array of
 *   default values if the parameter is repeatable.
 */

/**
 * @desc Parses and validates parameter definitions.
 * @ignore
 */
class ParameterParser {
  /**
   * Validates a set of parameters.
   * @param {...(ParameterDefinition|string)} parameters - The parameters to validate.
   * @returns {ParsedParameter[]} The validated parameters.
   * @throws {ParameterParserError} Thrown if an error is encountered during validation.
   */
  static validate(...parameters) {
    const parsed = ParameterParser.parse(...parameters);
    let seenRepeatable = false;
    let seenOptional = false;

    parsed.forEach(parameter => {
      if (parameter.literal && parsed.length > 1) {
        throw new _ParameterParserError2.default('Literal parameters must be the only parameter in a command.');
      } else if (seenRepeatable) {
        throw new _ParameterParserError2.default('Repeatable parameters must be the last parameter in a command.');
      } else if (seenOptional && !parameter.optional) {
        throw new _ParameterParserError2.default('Cannot have required parameters after optional parameters in a command.');
      }

      seenRepeatable = seenRepeatable || parameter.repeatable;
      seenOptional = seenOptional || parameter.optional;
    });

    return parsed;
  }

  /**
   * Parses a set of parameters into `ParsedParameter` objects.
   * @param {...(ParameterDefinition|string)} parameters - The parameters to parse.
   * @returns {ParsedParameter[]} The parsed parameters.
   * @throws {ParameterParserError} Thrown if an error is encountered during parsing.
   */
  static parse(...parameters) {
    const resolver = new _ParameterResolver2.default();

    return parameters.map(parameter => {
      if ((0, _lang.isString)(parameter)) {
        return new _ParsedParameter2.default(ParameterParser.parseParameter(parameter));
      } else if ((0, _lang.isPlainObject)(parameter)) {
        return new _ParsedParameter2.default(resolver.resolve(parameter));
      }

      throw new _ParameterParserError2.default('Expected parameter definition to be a plain object or string.');
    });
  }

  /**
   * Parses the given command parameter definition and returns an object
   *   containing data on it.
   * @param {String} parameter - The command parameter definition.
   * @returns {ParameterDefinition} Object containing data on the command parameter.
   * @throws {ParameterParserError} Thrown if the parameter definition is not
   *   well-formed.
   * @throws {TypeError} Thrown if the parameter definition is not a string.
   */
  static parseParameter(parameter) {
    if (!(0, _lang.isString)(parameter)) {
      throw new TypeError('Expected parameter to be a string.');
    }

    const trimmed = parameter.trim();

    if (!trimmed) {
      throw new _ParameterParserError2.default('Parameter cannot be empty.');
    }

    const parsed = { description: null };
    // description?
    const matched = trimmed.match(/^(.+?)\s*:\s*(.+)$/);

    if (matched) {
      parsed.description = matched[2];
    }

    return Object.assign({}, parsed, ParameterParser.parseDefinition(matched ? matched[1] : trimmed));
  }

  /**
   * Parses the definition portion of a parameter string.
   * @param {string} definition - The definition portion of a parameter string.
   * @returns {Object} An object containing data on the parsed parameter definition.
   * @throws {ParameterParserError} Thrown if the parameter definition is not
   *   well-formed.
   */
  static parseDefinition(definition) {
    const parsed = {
      name: null,
      optional: false,
      type: _Types.STRING,
      repeatable: false,
      literal: false,
      defaultValue: null
    };

    let temp = definition;

    // optional parameter?
    if (temp.startsWith('-')) {
      parsed.optional = true;
      temp = (0, _string.trimStart)(temp, '- ');
    } else if (temp.startsWith('+')) {
      temp = (0, _string.trimStart)(temp, '+ ');
    }

    // type declaration?
    let matched = temp.match(/\(\s*(\w+)\s*\)\s*(.+)/);

    if (matched) {
      const declaredType = matched[1];
      const actualType = (0, _Types.resolveType)(declaredType);

      if (!actualType) {
        throw new _ParameterParserError2.default(`Unrecognized parameter type declaration: '${definition}'.`);
      }

      parsed.type = actualType;
      temp = matched[2];
    }

    // name, repeatable, literal, default value?
    matched = temp.match(/(\w+\s*?[*+]?)\s*=\s*(.+)/);
    const name = matched ? matched[1] : temp;

    if (name.endsWith('*')) {
      parsed.name = (0, _string.trimEnd)(name, '* ');
      parsed.repeatable = true;
      parsed.defaultValue = [];
    } else if (name.endsWith('...')) {
      if (parsed.type !== _Types.STRING) {
        throw new _ParameterParserError2.default(`Literals can only be used with string parameters: '${definition}'.`);
      }

      parsed.name = (0, _string.trimEnd)(name, '. ');
      parsed.literal = true;
    } else if (name.includes(' ')) {
      throw new _ParameterParserError2.default(`Parameter name must not contain spaces: '${definition}'.`);
    } else {
      parsed.name = name;
    }

    if (matched) {
      const defaults = (0, _stringArgv2.default)(matched[2]);
      // default value automatically makes it optional
      parsed.optional = true;

      if (!parsed.repeatable && defaults.length > 1) {
        throw new _ParameterParserError2.default(`Cannot provide more than one default argument for non-repeatable parameters: '${definition}'.`);
      }

      const typedDefaults = defaults.map(value => {
        if (!(0, _Types.isType)(value, parsed.type)) {
          throw new _ParameterParserError2.default(`Given default value '${value}' is not of the correct type: '${definition}'.`);
        }

        return (0, _Types.convertType)(value, parsed.type);
      });

      parsed.defaultValue = parsed.repeatable ? typedDefaults : typedDefaults[0];
    }

    return parsed;
  }
}
exports.default = ParameterParser;