'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringArgv = require('string-argv');

var _stringArgv2 = _interopRequireDefault(_stringArgv);

var _lang = require('lodash/lang');

var _ArgumentParserError = require('../../errors/ArgumentParserError');

var _ArgumentParserError2 = _interopRequireDefault(_ArgumentParserError);

var _Types = require('./Types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @desc Handles parsing of commands given by users.
 * @ignore
 */
class ArgumentParser {
  /**
   * Parses an array of arguments for a command call.
   * @param {ParsedParameter[]} rules - An array of rules for the command being
   *   evaluated whose order matches that of the arguments.
   * @param {string} args - A string containing the arguments for this command.
   * @returns {Object} The parsed arguments given in a mapping between argument
   *   names and values.
   * @throws {ArgumentParserError} Thrown if required arguments are missing.
   */
  static parse(rules, args) {
    const delimited = (0, _stringArgv2.default)(args);
    const parsed = {};

    for (let i = 0; i < rules.length; ++i) {
      const rule = rules[i];

      if (!rule.optional && (0, _lang.isUndefined)(delimited[i])) {
        throw new _ArgumentParserError2.default(`Missing a value for required argument: '${rule.name}'.`);
      } else if (rule.repeatable || rule.literal) {
        if ((0, _lang.isUndefined)(delimited[i])) {
          // put the default value in and return since there's no other args
          return Object.assign({}, parsed, {
            [rule.name]: rule.defaultValue
          });
        }

        if (rule.repeatable) {
          const rest = [];

          // get the rest of the arguments
          for (let j = i; j < delimited.length; ++j) {
            rest.push(ArgumentParser.normalizeArgumentType(rule.type, delimited[j]));
          }

          return Object.assign({}, parsed, {
            [rule.name]: rest
          });
        } else if (rule.literal) {
          // use the entire string as the argument value
          return Object.assign({}, parsed, {
            [rule.name]: args
          });
        }
      }

      // get the arg or default value if no arg is given
      parsed[rule.name] = (0, _lang.isUndefined)(delimited[i]) ? rule.defaultValue : ArgumentParser.normalizeArgumentType(rule.type, delimited[i]);
    }

    return parsed;
  }

  /**
   * Converts an argument to the given type, ignoring string arguments.
   * @param {string} type - The type the argument should be converted to.
   * @param {string} argument - The argument to convertType.
   * @returns {ParameterType} The converted argument.
   * @throws {ArgumentParserError} Thrown if the argument is not convertable to
   *   the specified type.
   */
  static normalizeArgumentType(type, argument) {
    if (!(0, _Types.isType)(argument, type)) {
      throw new _ArgumentParserError2.default(`Expected argument '${argument}' to be of type '${type}'.`);
    }

    return (0, _Types.convertType)(argument, type);
  }
}
exports.default = ArgumentParser;