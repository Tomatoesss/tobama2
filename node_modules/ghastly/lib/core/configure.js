'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = configure;

var _lang = require('lodash/lang');

var _CommandObjectResolver = require('../resolvers/CommandObjectResolver');

var _CommandObjectResolver2 = _interopRequireDefault(_CommandObjectResolver);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Properties which are automatically handled when using object configurations.
 * @type {string[]}
 */
const DEFAULT_PROPERTIES = ['triggers', 'description', 'middleware'];

/**
 * Provides a bridge to provide configuration data for command configurators.
 *   Consumes a config object containing the configuration data and produces a
 *   function. This function consumes a configurator and returns another configurator
 *   with the given configuration applied to it.
 * Several `configure()` calls can be made successively on the returned configurator,
 *   with the outer config objects overwriting the keys in the innermost configs.
 * @param {Object} configuration - An object containing the configuration data
 *   to pass to the command configurator.
 * @returns {Function} A function consuming a configurator and producing another
 *   configurator with the provided config applied to it.
 * @throws {TypeError} Thrown if the given configuration is not a plain object.
 */
function configure(configuration) {
  if (!(0, _lang.isPlainObject)(configuration)) {
    throw new TypeError('Expected configuration to be a plain object.');
  }

  const resolver = new _CommandObjectResolver2.default();

  return configurator => {
    if (!(0, _lang.isFunction)(configurator)) {
      throw new TypeError('Expected configurator to be a function.');
    }

    return options => {
      // merge the original config and the next config
      const merged = Object.assign({}, configuration, options);
      // generate the configuration from the given configurator
      const bubbled = resolver.resolve(configurator(merged));

      return Object.assign({}, bubbled, DEFAULT_PROPERTIES.reduce((accumulated, property) => {
        switch (property) {
          case 'middleware':
            // additional middleware go on top of bubbled middleware
            return Object.assign({}, accumulated, {
              middleware: [...(merged[property] || []), ...bubbled.middleware]
            });
          default:
            return Object.assign({}, accumulated, {
              [property]: merged[property] || bubbled[property]
            });
        }
      }, {}));
    };
  };
}